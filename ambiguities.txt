Ambiguities

Paragraph: §7
Problem: The format for negative mixed rationals is ambiguous. It is not clear from the given examples if a negative quarter is acceptable as a negative fraction '-1/4' or is it necessary to display it as a mixed fraction with 0 as the whole number '-0_1/4'.
Our Solution: We decided to accept these negative non-mixed fractions such as '-1/4'.

Paragraph: §7
Problem: It is not clear if a minus sign can precede the fraction. E.g. '-345_-6/5'.
Our Solution: In standard mathematical notation, the fraction and numbers' sign cannot be seperate without being regarded as seperate numbers placed together via addition - so our compiler rejects this syntax.

Paragraph: §10, 11
Problem: Considering paragraph §9, which specifically states that zero length lists are allowed - how does this interact with the limitation on indexes to be within the the range of its length (positive to negative)?
Our Solution: N/A - Considering CUP parsing alone cannot detect this failure of array indexing being out of bounds, this ambiguity is beyond our scope to resolve.

Paragraph: §11
Problem: It is not clear if both indices can be omitted for a sequence slice '[:]'.
Our Solution: As it is supported in most other languages, our compiler will accept this syntax.

Paragraph: §13
Problem: It is ambiguous whether an empty declaration_list when using 'tdef' is allowed.
Our Solution: We accept empty type definitions as it may be desirable to have an equivalent of the empty tuple in haskell

Paragraph: §12
Problem: It is unclear the precedence of the operators
Our solution: We have largely followed C style precedence ! has highest precdence followed by ^, then * / with equal precedence, + - also with equal, then < <= = != at equal precedence, :: then in with lowest. The precedence can be overrided by using brackets like in C.

Paragraph: §20
Problem: It is stated that main returns no value
Our solution: In order to terminate the program early you may wish to use return so return would be valid with no value in main, however since most unix operating systems accept a value from program execution we will support using return with a value in main for compatibility as this is used extensively in unix to pipe results and such and the language would be highly restricted without it.

Paragraph: §13
Problem: It is ambiguous if type definitions are accepted inside functions
Our solution: We accept type definitions inside functions as you may want to have a type exposed only inside a specific function and not the others.

Paragraph: §14
Problem: It is ambiguous if function definitions are accepted inside functions
Our solution: We accept function definitions inside functions as you may want to have a function exposed only inside a specific function and not the others.
