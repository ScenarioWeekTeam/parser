 
import java_cup.runtime.*;

parser code {:

    scanner s;
    
    Parser(scanner s) {
        this.s = s;
    }
    
    public void syntax_error(Symbol current_token) {
        report_error(
            "Syntax error at line " + (current_token.left+1) + ", column "
            + current_token.right, null
        );
    }
:}

init with {: s.init(); :};

scan with {: return s.next_token(); :};

terminal LOOP, POOL, IF, THEN, ELSE, FI, BREAK, FDEF, TDEF, IN, ALIAS, READ, PRINT, MAIN, CHAR_TYPE, BOOL_TYPE, INT_TYPE, RAT_TYPE, FLOAT_TYPE, DICT_TYPE, SEQ_TYPE, TOP_TYPE, NULL, NOT, AND, OR, IMPLICATION, ADD, MINUS, TIMES, DIVIDE, POWER, LESSTHAN, LESSTHANEQUAL, EQUAL, NOTEQUAL, ASSIGN, LPARENS, RPARENS, COLON, LBRACKET, RBRACKET, SEMICOLON, GREATERTHAN, COMMA, QUESTION;
terminal Character CHAR;
terminal Integer INT;
terminal Rational RAT;
terminal Double FLOAT;
terminal String STRING;
terminal Character BOOL;
terminal String IDENTIFIER;

precedence nonassoc ELSE;
precedence left IN;
precedence left CONCAT;
precedence left AND, OR, IMPLICATION;
precedence left LESSTHAN, LESSTHANEQUAL, EQUAL, NOTEQUAL;
precedence left ADD, MINUS;
precedence left TIMES, DIVIDE;
precedence left POWER;
precedence right NOT;

program ::= stmtlist:s
    ;
stmtlist ::= stmtlist:s1 lcl_stmt:s
    ;
glbl_stmt ::= IDENTIFIER:identifier ASSIGN assign:e
    | IDENTIFIER:identifier COLON type:t SEMICOLON
    | IDENTIFIER:identifier COLON type:t ASSIGN assign:e SEMICOLON
    | TDEF LBRACE deccllist:d RBRACE SEMICOLON
    | FDEF IDENTIFIER:identifier LPARENS decllist:p RPARENS LBRACE stmtlist:s RBRACE SEMICOLON
    | FDEF IDENTIFIER:identifier LPARENS decllist:p RPARENS LBRACE stmtlist:s RBRACE COLON type:t SEMICOLON
    | MAIN LBRACE stmtlist:s RBRACE SEMICOLON
    ;
lcl_stmt ::= IDENTIFIER:identifier ASSIGN assign:e
    | IDENTIFIER:identifier COLON type:t SEMICOLON
    | IDENTIFIER:identifier COLON type:t ASSIGN assign:e SEMICOLON
    | READ IDENTIFIER:identifier SEMICOLON
    | PRINT expr:e SEMICOLON
    | IF LPARENS expr:e RPARENS THEN stmtlist:s FI
    | IF LPARENS expr:e RPARENS THEN stmtlist:s1 ELSE stmtlist:s2 FI
    | LOOP stmtlist:s POOL
    | BREAK expr:e SEMICOLON
    | BREAK SEMICOLON
    | RETURN expr:e SEMICOLON
    | RETURN SEMICOLON
    | QUESTION expr:e1 QUESTION IDENTIFIER:function LPARENS exprlist:e2 RPARENS SEMICOLON
    ;
exprlist ::= expr:e
    | exprlist:e1 COMMA expr:e2
    ;
expr ::= NOT expr:e
    | LPARENS expr:e RPARENS
    | expr:e1 AND expr:e2
    | expr:e1 OR expr:e2
    | expr:e1 IMPLICATION expr:e2
    | expr:e1 ADD expr:e2
    | expr:e1 MINUS expr:e2
    | expr:e1 TIMES expr:e2
    | expr:e1 DIVIDE expr:e2
    | MINUS expr:e
    | expr:e1 POWER expr:e2
    | expr:e1 LESSTHAN expr:e2
    | expr:e1 LESSTHANEQUAL expr:e2
    | expr:e1 EQUAL expr:e2
    | expr:e1 NOTEQUAL expr:e2
    | expr:e1 CONCAT expr:e2
    | NULL
    | BOOL:b
    | IDENTIFIER:i LBRACKET slice RBRACKET
    | IDENTIFIER:i
    | CHAR:c
    | FLOAT:f
    | RAT:r
    | INT:i
    | STRING:s
    | expr:e1 IN expr:e2
    | QUESTION expr:e1 QUESTION IDENTIFIER:function LPARENS exprlist:e2 RPARENS
    ;
slice ::= expr:e1 COLON expr:e2
    | COLON expr:e2
    | COLON
    | expr:e1 COLON
    ;
assign ::= expr:e
    | exprlist:e
    | LBRACKET exprlist:e RBRACKET
    | LBRACE dictlist:d RBRACE
    ;
dictlist ::= expr:e1 COLON expr:e2
    | dictlist:d COMMA expr:e1 COLON expr:e2
    ;
decllist ::= decl:d 
    | decllist:d1 COMMA decl:d2
    ;
decl ::= IDENTIFIER:identifier COLON type:t 
    ;
type ::= CHAR_TYPE
    | INT_TYPE
    | RAT_TYPE
    | FLOAT_TYPE
    | SEQ_TYPE LESSTHAN type:t GREATERTHAN
    | DICT_TYPE LESSTHAN type:t1 COMMA type:t2 GREATERTHAN
    | BOOL_TYPE
    | TOP_TYPE
    | IDENTIFIER:identifier
    ;
